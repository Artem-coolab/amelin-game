<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>–ü–æ–º–æ–≥–∏ –°–∞—à–µ —Å–æ–±—Ä–∞—Ç—å –∑–∞–∫–ª–∞–¥–∫–∏!</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #222;
            overflow: hidden;
            position: relative;
        }
        canvas {
            background-color: #000;
            border: 2px solid #555;
            display: block;
        }
        #scoreDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            z-index: 10;
        }

        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            z-index: 20;
        }
        .overlay-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        .overlay-screen p {
            font-size: 30px;
            margin-bottom: 30px;
            max-width: 70%;
        }
        .overlay-screen button {
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        .overlay-screen button:hover {
            background-color: #0056b3;
        }

        #gameOverScreen {
            display: none;
        }
        #gameCanvas, #scoreDisplay {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="scoreDisplay">–ó–∞–∫–ª–∞–¥–æ–∫: 0</div>
    
    <div id="startScreen" class="overlay-screen">
        <h1>–ü–æ–º–æ–≥–∏ –°–∞—à–µ —Å–æ–±—Ä–∞—Ç—å –∑–∞–∫–ª–∞–¥–∫–∏!</h1>
        <p>–£–ø—Ä–∞–≤–ª—è–π —à–ø—Ä–∏—Ü–æ–º, —Å–æ–±–∏—Ä–∞–π —Ç–∞–±–ª–µ—Ç–∫–∏, –∏–∑–±–µ–≥–∞–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö —É–∫–æ–ª–æ–≤ –∏ –≤—Å—Ç—Ä–µ—á–∏ —Å –º–µ–Ω—Ç–∞–º–∏!</p>
        <button onclick="startGame()">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
    </div>

    <div id="gameOverScreen" class="overlay-screen">
        <h1 id="gameOverMessage">–ü–æ—Ç—Ä–∞—á–µ–Ω–æ</h1>
        <p id="finalScore"></p>
        <button onclick="restartGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScore = document.getElementById('finalScore');

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –∏–≥—Ä–æ–∫–∞ (—à–ø—Ä–∏—Ü–∞)
        const PLAYER_EMOJI = 'üíâ';
        const PLAYER_EMOJI_FONT_SIZE = 40; // –£–í–ï–õ–ò–ß–ï–ù –†–ê–ó–ú–ï–† –®–ü–†–ò–¶–ê
        const SEGMENT_SIZE = 20; // –†–∞–∑–º–µ—Ä —Å–µ–≥–º–µ–Ω—Ç–∞
        let playerSpeed = 80; // –°–∫–æ—Ä–æ—Å—Ç—å –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö (—á–µ–º –º–µ–Ω—å—à–µ, —Ç–µ–º –±—ã—Å—Ç—Ä–µ–µ)
        let lastLogicUpdateTime = 0; // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ª–æ–≥–∏–∫–∏

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –≤—Ä–∞–≥–æ–≤ (–º–µ–Ω—Ç–æ–≤)
        const ENEMY_EMOJI = 'üëÆ';
        const ENEMY_FONT_SIZE = 30;

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ó–∞–∫–ª–∞–¥–æ–∫
        const COLLECTIBLE_EMOJI = 'üíä';
        const COLLECTIBLE_FONT_SIZE = 25; // –†–∞–∑–º–µ—Ä —Ç–∞–±–ª–µ—Ç–∫–∏ (–æ—Å—Ç–∞–µ—Ç—Å—è –º–µ–Ω—å—à–µ —à–ø—Ä–∏—Ü–∞)

        // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let player = {}; // –ì–æ–ª–æ–≤–∞ —à–ø—Ä–∏—Ü–∞
        let snakeBody = []; // –¢–µ–ª–æ —à–ø—Ä–∏—Ü–∞ (–º–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ {x, y, prevX, prevY})
        let dx, dy; // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è (-1, 0, 1)

        let collectible = {}; // –¢–µ–∫—É—â–∞—è –∑–∞–∫–ª–∞–¥–∫–∞
        let enemies = []; // –ú–∞—Å—Å–∏–≤ –º–µ–Ω—Ç–æ–≤

        let score = 0;
        let gameOver = false;
        let gameLogicInterval; // –î–ª—è setInterval –¥–ª—è –ª–æ–≥–∏–∫–∏ –∏–≥—Ä—ã
        let animationFrameId; // –î–ª—è requestAnimationFrame –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
        let enemySpawnTimeout1;
        let enemySpawnTimeout2;

        // -- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏–≥—Ä—ã --

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç, —á—Ç–æ–±—ã –æ–±—ä–µ–∫—Ç—ã –Ω–µ –Ω–∞–∫–ª–∞–¥—ã–≤–∞–ª–∏—Å—å
        function getRandomCoordinates() {
            const numCols = canvas.width / SEGMENT_SIZE;
            const numRows = canvas.height / SEGMENT_SIZE;
            
            let x, y;
            let isValidPosition = false;

            while (!isValidPosition) {
                x = Math.floor(Math.random() * numCols) * SEGMENT_SIZE;
                y = Math.floor(Math.random() * numRows) * SEGMENT_SIZE;
                isValidPosition = true;

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ–±—ã –Ω–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–µ —Å–æ–≤–ø–∞–¥–∞–ª–∞ —Å —Ç–µ–ª–æ–º –∑–º–µ–π–∫–∏ (–≤–∫–ª—é—á–∞—è –≥–æ–ª–æ–≤—É)
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –ø–æ—Å–ª–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ –ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ —à–∞–≥–∞, –µ—Å–ª–∏ –æ–Ω–∏ —É–∂–µ –∏–∑–≤–µ—Å—Ç–Ω—ã
                const potentialOccupiedPositions = [{x: player.x, y: player.y}, ...snakeBody]; // –í–∫–ª—é—á–∞–µ–º –≥–æ–ª–æ–≤—É –∏ –≤—Å–µ —Å–µ–≥–º–µ–Ω—Ç—ã
                
                for (let i = 0; i < potentialOccupiedPositions.length; i++) {
                    if (potentialOccupiedPositions[i].x === x && potentialOccupiedPositions[i].y === y) {
                        isValidPosition = false;
                        break;
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ–±—ã –Ω–µ —Å–æ–≤–ø–∞–¥–∞–ª–∞ —Å –º–µ–Ω—Ç–∞–º–∏ (—Å —É—á–µ—Ç–æ–º –∏—Ö —Ä–∞–∑–º–µ—Ä–∞)
                for (let i = 0; i < enemies.length; i++) {
                    const enemyRect = {
                        left: enemies[i].x,
                        right: enemies[i].x + ENEMY_FONT_SIZE,
                        top: enemies[i].y,
                        bottom: enemies[i].y + ENEMY_FONT_SIZE
                    };
                    const newPosRect = {
                        left: x,
                        right: x + SEGMENT_SIZE,
                        top: y,
                        bottom: y + SEGMENT_SIZE
                    };

                    if (newPosRect.left < enemyRect.right && newPosRect.right > enemyRect.left &&
                        newPosRect.top < enemyRect.bottom && newPosRect.bottom > enemyRect.top) {
                        isValidPosition = false;
                        break;
                    }
                }
            }
            return { x: x, y: y };
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∑–∞–∫–ª–∞–¥–∫–∏
        function spawnCollectible() {
            collectible = getRandomCoordinates();
            collectible.emoji = COLLECTIBLE_EMOJI;
            collectible.fontSize = COLLECTIBLE_FONT_SIZE;
            collectible.prevX = collectible.x;
            collectible.prevY = collectible.y;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–µ–Ω—Ç–∞
        class Enemy {
            constructor() {
                const spawnPos = getRandomCoordinates();
                this.x = spawnPos.x;
                this.y = spawnPos.y;
                this.prevX = this.x;
                this.prevY = this.y;
                this.emoji = ENEMY_EMOJI;
                this.fontSize = ENEMY_FONT_SIZE;
                this.speed = Math.random() * 0.2 + 0.5;
            }

            draw(interpolationFactor) {
                const interpolatedX = this.prevX + (this.x - this.prevX) * interpolationFactor;
                const interpolatedY = this.prevY + (this.y - this.prevY) * interpolationFactor;

                ctx.font = `${this.fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, interpolatedX + SEGMENT_SIZE / 2, interpolatedY + SEGMENT_SIZE / 2);
            }

            update() {
                this.prevX = this.x;
                this.prevY = this.y;

                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += this.speed * Math.cos(angle);
                this.y += this.speed * Math.sin(angle);
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–ª–∏ —Å–±—Ä–æ—Å –∏–≥—Ä—ã
        function initGame() {
            clearInterval(gameLogicInterval);
            cancelAnimationFrame(animationFrameId);
            clearTimeout(enemySpawnTimeout1);
            clearTimeout(enemySpawnTimeout2);

            score = 0;
            gameOver = false;
            player = { 
                x: Math.floor(canvas.width / 2 / SEGMENT_SIZE) * SEGMENT_SIZE, 
                y: Math.floor(canvas.height / 2 / SEGMENT_SIZE) * SEGMENT_SIZE,
                prevX: Math.floor(canvas.width / 2 / SEGMENT_SIZE) * SEGMENT_SIZE,
                prevY: Math.floor(canvas.height / 2 / SEGMENT_SIZE) * SEGMENT_SIZE
            };
            snakeBody = [];
            dx = SEGMENT_SIZE;
            dy = 0;
            enemies = [];
            playerSpeed = 80;
            lastLogicUpdateTime = performance.now();

            scoreDisplay.textContent = `–ó–∞–∫–ª–∞–¥–æ–∫: ${score}`;
            
            spawnCollectible();

            enemySpawnTimeout1 = setTimeout(() => {
                if (!gameOver) {
                    enemies.push(new Enemy());
                }
            }, 30000);
            
            enemySpawnTimeout2 = setTimeout(() => {
                if (!gameOver) {
                    enemies.push(new Enemy());
                }
            }, 180000);
            
            startGameLogicLoop();
            gameLoop(performance.now());
        }

        // –¶–∏–∫–ª –ª–æ–≥–∏–∫–∏ –∏–≥—Ä—ã (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π, —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è)
        function updateGameLogic() {
            if (gameOver) {
                clearInterval(gameLogicInterval);
                cancelAnimationFrame(animationFrameId);
                clearTimeout(enemySpawnTimeout1);
                clearTimeout(enemySpawnTimeout2);
                gameOverScreen.style.display = 'flex';
                finalScore.textContent = `–¢–≤–æ–π —Å—á–µ—Ç: ${score} –∑–∞–∫–ª–∞–¥–æ–∫`;
                return;
            }

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–∫ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –¥–ª—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏
            player.prevX = player.x;
            player.prevY = player.y;
            snakeBody.forEach(segment => {
                segment.prevX = segment.x;
                segment.prevY = segment.y;
            });

            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–ª–æ –∑–º–µ–π–∫–∏
            // –ö–∞–∂–¥—ã–π —Å–µ–≥–º–µ–Ω—Ç —Ö–≤–æ—Å—Ç–∞ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –Ω–∞ –º–µ—Å—Ç–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ
            for (let i = snakeBody.length - 1; i > 0; i--) {
                snakeBody[i].x = snakeBody[i - 1].x;
                snakeBody[i].y = snakeBody[i - 1].y;
            }
            // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –ø–µ—Ä–≤—ã–π —Å–µ–≥–º–µ–Ω—Ç —Ö–≤–æ—Å—Ç–∞ –Ω–∞ –º–µ—Å—Ç–æ –≥–æ–ª–æ–≤—ã
            if (snakeBody.length > 0) {
                snakeBody[0].x = player.x;
                snakeBody[0].y = player.y;
            }

            // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –≥–æ–ª–æ–≤—É
            player.x += dx;
            player.y += dy;

            // –ü—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–µ —Å–∫–≤–æ–∑—å —Å—Ç–µ–Ω—ã
            if (player.x < 0) player.x = canvas.width - SEGMENT_SIZE;
            else if (player.x >= canvas.width) player.x = 0;
            if (player.y < 0) player.y = canvas.height - SEGMENT_SIZE;
            else if (player.y >= canvas.height) player.y = 0;

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –∑–∞–∫–ª–∞–¥–∫–æ–π
            if (player.x === collectible.x && player.y === collectible.y) {
                score++;
                scoreDisplay.textContent = `–ó–∞–∫–ª–∞–¥–æ–∫: ${score}`;
                // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —Å–µ–≥–º–µ–Ω—Ç –≤ —Ö–≤–æ—Å—Ç.
                // –í–∞–∂–Ω–æ: –æ–Ω –¥–æ–ª–∂–µ–Ω –ø–æ—è–≤–∏—Ç—å—Å—è –≤ *—Å—Ç–∞—Ä–æ–π* –ø–æ–∑–∏—Ü–∏–∏ –≥–æ–ª–æ–≤—ã (–¥–æ –µ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è).
                // –î–ª—è —ç—Ç–æ–≥–æ –º—ã –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç –≤ –∫–æ–Ω–µ—Ü snakeBody,
                // –∞ –µ–≥–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –±—É–¥—É—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ —Å–ª–µ–¥—É—é—â–µ–º updateGameLogic
                // –∫–æ–≥–¥–∞ –æ–Ω –∑–∞–π–º–µ—Ç –ø–æ–∑–∏—Ü–∏—é –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞.
                // –í —ç—Ç–æ–º –ø–æ–¥—Ö–æ–¥–µ –Ω–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å prevX/prevY —Å—Ä–∞–∑—É,
                // —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –±—É–¥—É—Ç –æ–±–Ω–æ–≤–ª–µ–Ω—ã –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –¥–≤–∏–∂–µ–Ω–∏–∏.
                snakeBody.push({x: player.prevX, y: player.prevY, prevX: player.prevX, prevY: player.prevY}); 
                spawnCollectible();
                
                playerSpeed = Math.max(40, playerSpeed - 2);
                startGameLogicLoop();
            }

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ–Ω—Ç–æ–≤
            enemies.forEach(enemy => {
                enemy.update();
            });

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π –º–µ–Ω—Ç–æ–≤ (–ª–æ–≥–∏–∫–∞)
            enemies.forEach((enemy, index) => {
                const playerCenterX = player.x + SEGMENT_SIZE / 2;
                const playerCenterY = player.y + SEGMENT_SIZE / 2;
                const enemyCenterX = enemy.x + ENEMY_FONT_SIZE / 2;
                const enemyCenterY = enemy.y + ENEMY_FONT_SIZE / 2;

                const collisionThreshold = (SEGMENT_SIZE / 2) + (ENEMY_FONT_SIZE / 2) * 0.7; 

                // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ –º–µ–Ω—Ç–∞ —Å –≥–æ–ª–æ–≤–æ–π —à–ø—Ä–∏—Ü–∞
                const distPlayerEnemy = Math.sqrt(
                    Math.pow(playerCenterX - enemyCenterX, 2) +
                    Math.pow(playerCenterY - enemyCenterY, 2)
                );
                if (distPlayerEnemy < collisionThreshold) {
                    gameOver = true;
                    gameOverMessage.textContent = "–ü–æ—Ç—Ä–∞—á–µ–Ω–æ";
                    return; 
                }

                // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ –º–µ–Ω—Ç–∞ —Å —Ö–≤–æ—Å—Ç–æ–º —à–ø—Ä–∏—Ü–∞
                for (let i = 0; i < snakeBody.length; i++) {
                    const segmentCenterX = snakeBody[i].x + SEGMENT_SIZE / 2;
                    const segmentCenterY = snakeBody[i].y + SEGMENT_SIZE / 2;

                    const distBodyEnemy = Math.sqrt(
                        Math.pow(segmentCenterX - enemyCenterX, 2) +
                        Math.pow(segmentCenterY - enemyCenterY, 2)
                    );
                    
                    if (distBodyEnemy < collisionThreshold) {
                        snakeBody.splice(i);
                        score = snakeBody.length;
                        scoreDisplay.textContent = `–ó–∞–∫–ª–∞–¥–æ–∫: ${score}`;
                        enemies.splice(index, 1);
                        break; 
                    }
                }
            });
            enemies = enemies.filter(enemy => 
                enemy.x > -ENEMY_FONT_SIZE && enemy.x < canvas.width + ENEMY_FONT_SIZE &&
                enemy.y > -ENEMY_FONT_SIZE && enemy.y < canvas.height + ENEMY_FONT_SIZE
            );

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è –≥–æ–ª–æ–≤—ã —Å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–º —Ç–µ–ª–æ–º
            // –ò—Ç–µ—Ä–∏—Ä—É–µ–º —Å 1-–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞, —Ç.–∫. 0-–π —ç–ª–µ–º–µ–Ω—Ç snakeBody - —ç—Ç–æ —Ç–∞ –∫–ª–µ—Ç–∫–∞, –≥–¥–µ —Ç–æ–ª—å–∫–æ —á—Ç–æ –±—ã–ª–∞ –≥–æ–ª–æ–≤–∞.
            // –ü—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏ —Å –∑–∞–∫–ª–∞–¥–∫–æ–π, –Ω–æ–≤—ã–π —Å–µ–≥–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –≤ –∫–æ–Ω–µ—Ü snakeBody.
            // –í —Å–ª–µ–¥—É—é—â–µ–º –ª–æ–≥–∏—á–µ—Å–∫–æ–º —à–∞–≥–µ –æ–Ω –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—Å—è –Ω–∞ –º–µ—Å—Ç–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ, –∏ —Ç.–¥.
            // –ü–æ—ç—Ç–æ–º—É, —Å–∞–º—ã–π –ø–µ—Ä–≤—ã–π —Å–µ–≥–º–µ–Ω—Ç –≤ snakeBody (snakeBody[0]) - —ç—Ç–æ —Ç–æ—Ç,
            // –∫–æ—Ç–æ—Ä—ã–π —Ç–æ–ª—å–∫–æ —á—Ç–æ –±—ã–ª –≥–æ–ª–æ–≤–æ–π. –° –Ω–∏–º —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è –±—ã—Ç—å –Ω–µ –¥–æ–ª–∂–Ω–æ.
            // –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Å —Å–µ–≥–º–µ–Ω—Ç–∞ –ø–æ–¥ –∏–Ω–¥–µ–∫—Å–æ–º 1 (—Ç–æ –µ—Å—Ç—å, —Å–æ –≤—Ç–æ—Ä–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞ —Ö–≤–æ—Å—Ç–∞).
            for (let i = 1; i < snakeBody.length; i++) { 
                if (player.x === snakeBody[i].x && player.y === snakeBody[i].y) {
                    gameOver = true;
                    gameOverMessage.textContent = "–£–∂–∞–ª–∏–ª—Å—è!";
                    break;
                }
            }
            lastLogicUpdateTime = performance.now();
        }

        // –¶–∏–∫–ª –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ (requestAnimationFrame)
        function gameLoop(currentTime) {
            if (gameOver) {
                return;
            }

            animationFrameId = requestAnimationFrame(gameLoop);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // –§–∞–∫—Ç–æ—Ä –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏ –Ω–µ –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–≤—ã—à–∞—Ç—å 1, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å "–ø–µ—Ä–µ—Å–∫–æ–∫–∞"
            let interpolationFactor = (currentTime - lastLogicUpdateTime) / playerSpeed;
            if (interpolationFactor > 1) interpolationFactor = 1;

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∑–∞–∫–ª–∞–¥–∫–∏
            ctx.font = `${collectible.fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(collectible.emoji, collectible.x + SEGMENT_SIZE / 2, collectible.y + SEGMENT_SIZE / 2);

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≥–æ–ª–æ–≤—ã —à–ø—Ä–∏—Ü–∞ —Å –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–µ–π
            const interpolatedPlayerX = player.prevX + (player.x - player.prevX) * interpolationFactor;
            const interpolatedPlayerY = player.prevY + (player.y - player.prevY) * interpolationFactor;
            ctx.font = `${PLAYER_EMOJI_FONT_SIZE}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(PLAYER_EMOJI, interpolatedPlayerX + SEGMENT_SIZE / 2, interpolatedPlayerY + SEGMENT_SIZE / 2);

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ç–µ–ª–∞ —à–ø—Ä–∏—Ü–∞ —Å –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–µ–π
            for (let i = 0; i < snakeBody.length; i++) {
                const segment = snakeBody[i];
                // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ prevX/prevY —Å—É—â–µ—Å—Ç–≤—É—é—Ç (–¥–ª—è –Ω–æ–≤–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞ –æ–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å —Ç–∞–∫–∏–º–∏ –∂–µ, –∫–∞–∫ x/y)
                const segPrevX = segment.prevX !== undefined ? segment.prevX : segment.x;
                const segPrevY = segment.prevY !== undefined ? segment.prevY : segment.y;

                const interpolatedSegmentX = segPrevX + (segment.x - segPrevX) * interpolationFactor;
                const interpolatedSegmentY = segPrevY + (segment.y - segPrevY) * interpolationFactor;
                ctx.fillText(COLLECTIBLE_EMOJI, interpolatedSegmentX + SEGMENT_SIZE / 2, interpolatedSegmentY + SEGMENT_SIZE / 2);
            }

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –º–µ–Ω—Ç–æ–≤ —Å –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–µ–π
            enemies.forEach(enemy => {
                enemy.draw(interpolationFactor);
            });
        }

        // –ó–∞–ø—É—Å–∫ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –ª–æ–≥–∏–∫–∏ –∏–≥—Ä—ã
        function startGameLogicLoop() {
            clearInterval(gameLogicInterval);
            gameLogicInterval = setInterval(updateGameLogic, playerSpeed);
        }

        // -- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ --

        document.addEventListener('keydown', (e) => {
            if (gameOver) return;

            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    if (dy === 0) { dx = 0; dy = -SEGMENT_SIZE; } break;
                case 'ArrowDown': case 's': case 'S':
                    if (dy === 0) { dx = 0; dy = SEGMENT_SIZE; } break;
                case 'ArrowLeft': case 'a': case 'A':
                    if (dx === 0) { dx = -SEGMENT_SIZE; dy = 0; } break;
                case 'ArrowRight': case 'd': case 'D':
                    if (dx === 0) { dx = SEGMENT_SIZE; dy = 0; } break;
            }
        });

        // -- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞–º–∏ --

        function startGame() {
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            canvas.style.display = 'block';
            scoreDisplay.style.display = 'block';
            initGame();
        }

        function restartGame() {
            startGame();
        }

        document.addEventListener('DOMContentLoaded', () => {
            startScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            canvas.style.display = 'none';
            scoreDisplay.style.display = 'none';
        });
    </script>
</body>
</html>